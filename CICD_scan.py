
import sys
import json
import time
import argparse
import requests as req
import requests
from urllib3.exceptions import InsecureRequestWarning
import ssl
import os
import threading
import urllib.request

client_cert = None
client_key = None
class SSLContextAdapter(requests.adapters.HTTPAdapter):

    def init_poolmanager(self, *args, **kwargs):
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
        context.load_cert_chain(certfile=client_cert, keyfile=client_key)
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE

        kwargs['ssl_context'] = context
        return super(SSLContextAdapter, self).init_poolmanager(*args, **kwargs)

class ScanEngine:

    ''' initializing class variables '''
    def __init__(self, fptUrl, clientCert, clientKey, iamuserName, userEmail, accountId, scanUrl, scanType, proxyEnabled):
        self.fptUrl = fptUrl
        self.clientCert = clientCert
        self.clientKey = clientKey
        self.iamuserName = iamuserName
        self.userEmail = userEmail
        self.accountId = accountId
        self.scanUrl = scanUrl
        self.assetUuid = ''
        self.scanType = scanType
        self.proxyEnabled = proxyEnabled
        self.apiKeyGenerationApiUrl = f'{fptUrl}/api/v2.0/auth/keygen'
        self.addAssetApiUrl = f'{fptUrl}/api/v2.0/asset/add/'
        self.authAssetApiUrl = f'{fptUrl}/api/v2.0/asset/auth' 
        self.changeProxyApiUrl = f'{fptUrl}/api/v2.0/asset/change_asset_proxy'
        self.scanStartApiUrl = f'{fptUrl}/api/v1.0/cmdb/scan/start'
        self.scanStopApiUrl = f'{fptUrl}/api/v1.0/cmdb/scan/stop'
        self.client = requests.Session()
        self.client.mount('https://', SSLContextAdapter())
        self.scanFlag = False
        self.proxyMgtIPPORT = ""

    def GenerateAPIKEY(self, lic_model):
        ''' generates the API KEY '''
        requestBody = {}
        requestBody['lic_model'] = lic_model
        requestBody['email'] = self.userEmail
        requestBody['account_id'] = self.accountId
        if len(self.iamuserName) > 0:
            requestBody['iam_user_name'] = self.iamuserName

        jsonData = json.dumps(requestBody)
        return self.DoPostRequest(self.apiKeyGenerationApiUrl,jsonData)

    def AddAsset(self, licSerial):
        ''' adds the Asset to FortiPenTest '''
        requestBody = {}
        requestBody['new_fqdn'] = self.scanUrl
        requestBody['serial'] = licSerial
        requestBody['email'] = self.userEmail
        if len(self.iamuserName) > 0:
            requestBody['iam_acc_id'] = self.accountId
            requestBody['iam_user_name'] = self.iamuserName
        jsonData = json.dumps(requestBody)
        return self.DoPostRequest(self.addAssetApiUrl, jsonData)


    def change_asset_proxy(self, uuid, proxyenable, licSerial):
        ''' get all the assets specific to a user and serial(ApiKey represents specific serial)'''
        requestBody = {'uuid':uuid, 'proxyenable':proxyenable, 'serial':licSerial}
        jsonData = json.dumps(requestBody)
        return self.DoPostRequest(self.changeProxyApiUrl,jsonData)


    def AuthStatus(self, apiKey, assetUuid):
        '''Gets the authorization status, whether its successful or failed or bypassed'''
        authStatusApiUrl='{0}/api/v1.0/query/authstatus?url={1}&uuid={2}'.format(self.fptUrl, self.scanUrl, assetUuid)
        responseJson = None
        headers = {"X-API-Key":"{0}".format(apiKey)}
        jsonTxt, getError = self.DoGetRequest(authStatusApiUrl,headers)
        if getError:
            return jsonTxt, True
        responseJson = json.loads(jsonTxt)
        return responseJson, False

    def AuthorizeAsset(self, serial):
        ''' authorizes the asset '''
        requestBody = {}
        requestBody['fqdn'] = self.scanUrl
        requestBody['email'] = self.userEmail
        requestBody['serial'] = serial
        if len(self.iamuserName) > 0:
            requestBody['iam_acc_id'] = self.accountId
            requestBody['iam_user_name'] = self.iamuserName
        jsonData = json.dumps(requestBody)
        return self.DoPostRequest(self.authAssetApiUrl,jsonData)

    def GetScanStatus(self, apiKey, licSerial, assetUuid):
        ''' Gets the scan status of an asset '''
        scanStatusApiUrl='{0}/api/v1.0/query/scanstatus?url={1}&uuid={2}'.format(
                  self.fptUrl, self.scanUrl, assetUuid)
        responseJson = None
        headers = {"X-API-Key":"{0}".format(apiKey)}
        jsonTxt, getError = self.DoGetRequest(scanStatusApiUrl,headers)
        if getError:
            return jsonTxt, True

        responseJson = json.loads(jsonTxt)

        error_msg = responseJson['Status'][0]['error_msg']
        if error_msg != "" and self.scanFlag:
            print(f'Scan failed with error_msg: {error_msg}')
            sys.exit(1)
        if "Authorization Failed" in jsonTxt or "not authorized" in jsonTxt:
            scanStatus = responseJson['Status'][0]['scan_status']
            print(f'scan status of an asset {self.scanUrl} : {scanStatus}')
            sys.exit(1)
        if "Scan Request in Queue" in jsonTxt:
            print("Scan Request in Queue")
        return jsonTxt, False

    def DoPostRequest(self, endPoint, requestBody, apiKey = None):
        ''' Do Post Request '''
        responseJson = None
        if "api/v2.0" in endPoint:
            headers = { "Accept": "application/json"}
            resp= self.client.post(endPoint, headers=headers, data=requestBody,
                                   timeout=25, verify=False)
        else:
            headers = {"X-API-Key":"{0}".format(apiKey)}
            resp= self.client.post(endPoint, headers=headers, data=requestBody,
                               verify=False, timeout=25)

        responseJson = resp.json()
        if resp.status_code >= 400 and resp.status_code <= 599:
            status = None
            try:
                statusObj = responseJson['Status']
                status = statusObj['status']
            except:
                status = responseJson['Status']
            return status,True
        return responseJson, False



    def StopScan(self,apiKey,assetUuid):
        ''' Stops the scan '''
        requestBody = {}
        requestBody['url'] = self.scanUrl
        requestBody['uuid'] = assetUuid
        jsonData = json.dumps(requestBody)
        return self.DoPostRequest(self.scanStopApiUrl, jsonData,apiKey)

    def StartScan(self, apiKey, assetUuid, licSerial, count = 0):
        ''' starts the scan '''
        requestBody = {}
        requestBody['url'] = self.scanUrl
        requestBody['uuid'] = assetUuid
        requestBody['scan_type'] = self.scanType
        jsonData = json.dumps(requestBody)
        startScanResp, isError = self.DoPostRequest(self.scanStartApiUrl, jsonData, apiKey)
        time.sleep(10)
        startScanResp = json.dumps(startScanResp)

        if not "Scan Request Successfull" in startScanResp or isError:
            if "not authorized" in startScanResp:
                print(f'Authorizing the asset: {self.scanUrl}.')
                authAssetResp, isError = self.AuthorizeAsset(licSerial)
                if isError:
                    print(authAssetResp)
                    self.exitproxy()
                    sys.exit(1)
                count = count + 1
                if count > 3:
                    print(startScanResp)
                    self.exitproxy()
                    sys.exit(1)
                self.StartScan(apiKey, assetUuid, licSerial,count)
            else:
                print(startScanResp)
                print("Failed to start scan")
                self.exitproxy()
                sys.exit(1)
        print("Scan started on the target %s" %(self.scanUrl))
        return startScanResp


    def GetScanResults(self, apiKey, assetUuid):
        ''' Gets the scan results of an asset '''
        scanSummaryApiUrl='{0}/api/v1.0/query/results?url={1}&uuid={2}'.format(
                self.fptUrl, self.scanUrl, assetUuid)
        headers = {"X-API-Key":"{0}".format(apiKey)}
        return self.DoGetRequest(scanSummaryApiUrl,headers)

    def DoGetRequest(self, endPoint, headers):
        ''' Do Get Request '''
        resp  = self.client.get(endPoint, headers=headers,
                              verify=False, timeout=25)
        responseJson = resp.json()
        if resp.status_code >= 400 and resp.status_code <= 599:
            status = None
            try:
                statusObj = responseJson['Status']
                status = statusObj['status']
            except Exception:
                status = responseJson['Status']
            return status, True
        jsonTxt = json.dumps(responseJson)
        return jsonTxt, False

    def GenerateScanResultUrl(self, apiKey, assetUuid):
        ''' Gets the scan result url fragment of an asset '''
        scanResultFragApiUrl='{0}/api/v1.0/query/scanresulturl?url={1}&uuid={2}'.format(
                self.fptUrl, self.scanUrl, assetUuid)
        headers = {"X-API-Key":"{0}".format(apiKey)}
        return self.DoGetRequest(scanResultFragApiUrl,headers)

    def GenerateScanConfigUrl(self, apiKey, assetUuid):
        ''' Gets the scan config url fragment of an asset '''
        scanConfigFragApiUrl='{0}/api/v1.0/query/scanconfigurl?url={1}&uuid={2}'.format(
                self.fptUrl, self.scanUrl, assetUuid)
        headers = {"X-API-Key":"{0}".format(apiKey)}
        return self.DoGetRequest(scanConfigFragApiUrl,headers)

    def updateMgtIPPORT(self, proxyMgtIPPORT):
        self.proxyMgtIPPORT = proxyMgtIPPORT 

    def exitproxy(self):
        try:
            headers = {"Accept": "application/json"}
            proxyExitUrl='http://' + self.proxyMgtIPPORT + '/exit'
            r = req.get(proxyExitUrl)
        except requests.exceptions.ConnectionError:
            pass # as GIN service exit will return empty response

    def pingproxy(self, proxyMgtIPPORT):
        up = False
        t_end = time.time() + 15  # 15 sec timeout
        r = None
        while time.time() < t_end:
            time.sleep(5)
            # PING PROXY
            try:
                headers = {"Accept": "application/json"}
                proxyPingUrl='http://' + proxyMgtIPPORT + '/ping'
                r = req.get(proxyPingUrl)
                if r:
                    responseJson = r.json()
                    return responseJson["message"]
            except requests.exceptions.ConnectionError:
                print("Waiting for GIN service to come UP...")
        return ""

    def invoke_proxyserver(self, domain, lic_serial):
        cmd = './fptproxyserver %s %s %s'%(domain, lic_serial, self.assetUuid)
        os.system(cmd)

if __name__ == '__main__':

    parser = argparse.ArgumentParser(description= "Scan Configuration for "\
                                     "trigering Scan.")

    parser.add_argument("fortipentestUrl", help="Please provide the FortiPenTest Url")
    parser.add_argument("clientCert", help="Please provide the file path for Fortinet Product web certificate public key")
    parser.add_argument("clientKey", help="Please provide the file path for Fortinet Product web certificate private key")
    parser.add_argument("userEmail", help="Please provide the user email")
    parser.add_argument("accountId", help="Please provide the accountid")
    parser.add_argument("scanUrl",help="Scan Url on which scan to be triggered")
    parser.add_argument("scanType", help="Quick Scan=0, Full Scan=1")
    parser.add_argument("proxyEnabled", help="Proxy Enabled=True, Proxy Disabled=False")
    parser.add_argument("-i", "--iamuserName", help="Please provide the IAMUserName", required=False, default="")
    args = parser.parse_args()


    inargs_fptUrl = args.fortipentestUrl
    inargs_clientCert = args.clientCert
    inargs_clientKey = args.clientKey
    inargs_userEmail = args.userEmail
    inargs_accountId = args.accountId
    inargs_scanUrl = args.scanUrl
    inargs_scanType = int(args.scanType)
    inargs_proxyEnabled = bool(args.proxyEnabled)
    inargs_iamuserName = ""
    if args.iamuserName:
        inargs_iamuserName = args.iamuserName
    client_cert = inargs_clientCert
    client_key = inargs_clientKey

    scanEngine = ScanEngine(inargs_fptUrl, inargs_clientCert,inargs_clientKey,inargs_iamuserName,inargs_userEmail, inargs_accountId, inargs_scanUrl,
                            inargs_scanType, inargs_proxyEnabled)

    try:
        requests.packages.urllib3.disable_warnings(category=
                                                   InsecureRequestWarning)




        # GENERATE KEY
        genApiKeyResp, isError = scanEngine.GenerateAPIKEY("fpt")
        if isError:
            print(genApiKeyResp)
            sys.exit(1)
        apiKey = genApiKeyResp['Status']['api_key']
        licSerial = genApiKeyResp['Status']['serial']
        print(f'Generated APIKey : {apiKey} for email {inargs_userEmail} {licSerial}')




        # ADD ASSET
        addAssetResp, isError = scanEngine.AddAsset(licSerial)
        if isError:
            print(addAssetResp)
            scanEngine.exitproxy()
            sys.exit(1)
        print(addAssetResp)
        scanEngine.assetUuid = addAssetResp['Status']['uuid']




        # PROXY SERVER EXECUTION BEING - PENDING - NEED TO CHANGE IT TO SUBPROCESS INSTEAD OF THREAD IN CASE OF ANY ISSUES
        proxythread = threading.Thread(target=scanEngine.invoke_proxyserver, args=[inargs_fptUrl.split("https://")[1], licSerial])
        proxythread.start()

        print("Waiting for proxyserver to create tunnels...")
        time.sleep(10)
        tmpfound = False
        proxyMgtIPPORT = ""
        t_end = time.time() + 60  # 60 sec timeout
        while time.time() < t_end:
            if os.path.isfile("./tmp"):
                tmpfound = True
                f = open("./tmp", "r")
                proxyMgtIPPORT = f.read()
                break
            else:
                print("Waiting for GIN PORT...")
                time.sleep(10)

        scanEngine.updateMgtIPPORT(proxyMgtIPPORT)

        if tmpfound:
            ping = scanEngine.pingproxy(proxyMgtIPPORT)
        else:
            sys.exit(1)
        if ping == "pong":
            print("Proxy Server is UP and reachable")
        else:
            print("Proxy Server is not reachable")
            scanEngine.exitproxy()
            sys.exit(1)




        # ENABLE PROXY CONFIG
        print("Checking proxy flag... ", scanEngine.proxyEnabled)
        if(scanEngine.proxyEnabled == True):
            changeProxyResponse, isError = scanEngine.change_asset_proxy(scanEngine.assetUuid, scanEngine.proxyEnabled, licSerial)
            if changeProxyResponse == "Failed":
                print("Unable to update the proxy information : ", changeProxyResponse)
                scanEngine.exitproxy()
                sys.exit(1)





        # CHECK AUTH STATUS
        # Making sure asset scan is NOT in progress
        # NOTE: AUTHORIZE ASSET MUST NOT BE CALLED MULTIPLE TIMES. OR WHEN THE SCAN IS RUNNING
        authStatusResp, isError = scanEngine.AuthStatus(apiKey, scanEngine.assetUuid)
        if isError:
            print(authStatusResp)
            scanEngine.exitproxy()
            sys.exit(1)
        if("Not Started" in authStatusResp['Status'][0]['scan_status'] or 
           "Complete" in authStatusResp['Status'][0]['scan_status'] or 
           "Stopped" in authStatusResp['Status'][0]['scan_status'] or
           "failed" in str(authStatusResp['Status'][0]['scan_status']).lower()):
            print(f'Authorizing the asset: {scanEngine.scanUrl}.')
            authAssetResp, isError = scanEngine.AuthorizeAsset(licSerial)
            time.sleep(5)
            if isError:
                print(authAssetResp)
                scanEngine.exitproxy()
                sys.exit(1)
            print("Authorization process:", authAssetResp['Status']['mesg'])
        else:
            print("Scan is already in progress for the provided asset")
            scanEngine.exitproxy()
            sys.exit(1)





        # CHECKING FOR AUTHORIZATION COMPLETION
        authStatusResp, isError = scanEngine.AuthStatus(apiKey, scanEngine.assetUuid)
        if isError:
            print(authStatusResp)
            scanEngine.exitproxy()
            sys.exit(1)
        t_end = time.time() + 60 * 2  # 2 minutes timeout
        while time.time() < t_end:
            time.sleep(4)
            authStatusResp, isError = scanEngine.AuthStatus(apiKey, scanEngine.assetUuid)
            if isError or "Failed" in authStatusResp['Status'][0]['scan_status']:
                print(authStatusResp)
                scanEngine.exitproxy()
                sys.exit(1)
            if "Initialization In Progress" not in authStatusResp['Status'][0]['scan_status'] and "Authorization Request In Progress" not in authStatusResp['Status'][0]['scan_status']:
                print(authStatusResp)
                break
            print("...")
        # MAKING SURE AUTH STATUS IS EITHER ONE OF [success, not started, stopped, completed]
        if("success" not in authStatusResp['Status'][0]['scan_status'].lower() and 
           "not started" not in authStatusResp['Status'][0]['scan_status'].lower() and 
           "stopped" not in authStatusResp['Status'][0]['scan_status'].lower() and 
           "complete" not in authStatusResp['Status'][0]['scan_status'].lower()):
            print(authStatusResp)
            scanEngine.exitproxy()
            sys.exit(1)



        # GET SCAN CONFIG URL
        scanConfigUrlResp, isError = scanEngine.GenerateScanConfigUrl(apiKey,scanEngine.assetUuid)
        if isError:
            print(scanConfigUrlResp)
            scanEngine.exitproxy()
            sys.exit(1)
        scanConfigUrlResp = json.loads(scanConfigUrlResp)
        scanConfigUrl = scanConfigUrlResp['Status'][0]['scanconfig_url']
        print(f'Scan Config Url fragment for an asset {scanEngine.scanUrl}: {scanConfigUrl}')





        # GET SCAN RESULTS URL
        scanResultUrlResp, isError = scanEngine.GenerateScanResultUrl(apiKey,scanEngine.assetUuid)
        if isError:
            print(scanResultUrlResp)
            scanEngine.exitproxy()
            sys.exit(1)
        scanResultUrlResp = json.loads(scanResultUrlResp)
        scanResultUrl = scanResultUrlResp['Status'][0]['scanresult_url']
        print(f'Scan Result Url fragment for an asset {scanEngine.scanUrl}: {scanResultUrl}')




        # GET SCAN STATUS
        scanStatusResp, isError = scanEngine.GetScanStatus(apiKey, licSerial,  scanEngine.assetUuid)
        if isError:
            print(scanStatusResp)
            scanEngine.exitproxy()
            sys.exit(1)





        # If SCAN ALREADY RUNNING, STOP CURRENT SCAN.
        # Making sure scan does not start again(if already running).
        if("Initialization In Progress" not in scanStatusResp and 
           "Authorization request in Progress" not in scanStatusResp and 
           "Authorization Request In Progress" not in scanStatusResp and 
           "In Progress" in scanStatusResp):
            print("stopping current Active Scan")
            stopScanResp, isError = scanEngine.StopScan(apiKey, scanEngine.assetUuid)
            time.sleep(10)
            if isError:
                print(stopScanResp)
                print("Fail to trigger Stop Scan")
                scanEngine.exitproxy()
                sys.exit(1)
            stopScanResp = json.dumps(stopScanResp)
            if not "Scan Stop Request Successful" in stopScanResp:
                print(stopScanResp)
                print("Fail to trigger Stop Scan")
                scanEngine.exitproxy()
                sys.exit(1)





        # TRIGGER SCAN
        scanEngine.StartScan(apiKey, scanEngine.assetUuid, licSerial)
        # As scan is started scan flag is set to true
        scanEngine.scanFlag = True





        # CHECK FOR SCAN STATUS AND LOOP IT
        scanStatusResp = scanEngine.GetScanStatus(apiKey, licSerial, scanEngine.assetUuid)
        if isError:
            print(scanStatusResp)
            scanEngine.exitproxy()
            sys.exit(1)
        while "Scan Complete" not in scanStatusResp:
            # IN CASE OF SCAN ERRORS, CODE WILL EXIT (in GetScanStatus function)
            scanStatusResp, isError = scanEngine.GetScanStatus(apiKey, licSerial,  scanEngine.assetUuid)
            # IN CASE OF ERROR IN GETSCANSTATUS API, it will exit below
            if isError:
                print(scanStatusResp)
                scanEngine.exitproxy()
                sys.exit(1)
            # IF SCANSTATUS IS STOPPED, it will exit
            if "Stopped" in scanStatusResp:
                print("Scan stopped.")
                scanEngine.exitproxy()
                sys.exit(1)
            time.sleep(30)




        print("Scan completed Successfully")
        scanEngine.exitproxy()



        # GET FINAL SCAN RESULTS
        scanresultResp, isError = scanEngine.GetScanResults(apiKey,scanEngine.assetUuid)
        if isError:
            print(scanresultResp)
            sys.exit(1)
        print(f'ScanResults of an asset: {scanEngine.scanUrl}')
        print(scanresultResp)




    # IN CASE OF ANY OTHER UNEXPECTED ERROR
    except Exception as ex:
        print("Exception while triggering scan:", ex.__class__, ex)
        sys.exit(1)
    finally:
        scanEngine.client.close()
